import { c as MaybePromise, d as StreamableHTTPEdgeClientTransport, f as SSEEdgeClientTransport, l as ServeOptions, n as MCPClientOAuthCallbackConfig, o as BaseTransportType, r as MCPClientOAuthResult, s as CORSOptions } from "../client-Csp_m13H.js";
import "../mcp-Dw5vDrY8.js";
import "../do-oauth-client-provider-DGc5pP0l.js";
import "../index-DhJCaDWd.js";
import "../ai-types-D5YoPrBZ.js";
import { c as ConnectionContext, s as Connection, t as Agent } from "../index-DFqsR7mb.js";
import { ElicitRequest, ElicitRequestSchema, ElicitResult, ElicitResult as ElicitResult$1, JSONRPCMessage } from "@modelcontextprotocol/sdk/types.js";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";

//#region src/mcp/worker-transport.d.ts
interface WorkerTransportOptions {
  sessionIdGenerator?: () => string;
  enableJsonResponse?: boolean;
  onsessioninitialized?: (sessionId: string) => void;
  corsOptions?: CORSOptions;
}
declare class WorkerTransport implements Transport {
  private started;
  private initialized;
  private sessionIdGenerator?;
  private enableJsonResponse;
  private onsessioninitialized?;
  private standaloneSseStreamId;
  private streamMapping;
  private requestToStreamMapping;
  private requestResponseMap;
  private corsOptions?;
  private protocolVersion?;
  sessionId?: string;
  onclose?: () => void;
  onerror?: (error: Error) => void;
  onmessage?: (message: JSONRPCMessage) => void;
  constructor(options?: WorkerTransportOptions);
  start(): Promise<void>;
  private validateProtocolVersion;
  private getHeaders;
  handleRequest(request: Request, parsedBody?: unknown): Promise<Response>;
  private handleGetRequest;
  private handlePostRequest;
  private handleDeleteRequest;
  private handleOptionsRequest;
  private handleUnsupportedRequest;
  private validateSession;
  close(): Promise<void>;
  send(message: JSONRPCMessage): Promise<void>;
}
//#endregion
//#region src/mcp/handler.d.ts
interface CreateMcpHandlerOptions extends WorkerTransportOptions {
  /**
   * The route path that this MCP handler should respond to.
   * If specified, the handler will only process requests that match this route.
   * @default "/mcp"
   */
  route?: string;
  /**
   * CORS configuration options for handling cross-origin requests.
   * These options are passed to the WorkerTransport which handles adding
   * CORS headers to all responses.
   *
   * Default values are:
   * - origin: "*"
   * - headers: "Content-Type, Accept, Authorization, mcp-session-id, MCP-Protocol-Version"
   * - methods: "GET, POST, DELETE, OPTIONS"
   * - exposeHeaders: "mcp-session-id"
   * - maxAge: 86400
   *
   * Provided options will overwrite the defaults.
   */
  corsOptions?: CORSOptions;
}
type OAuthExecutionContext = ExecutionContext & {
  props?: Record<string, unknown>;
};
declare function createMcpHandler(server: McpServer | Server, options?: CreateMcpHandlerOptions): (request: Request, env: unknown, ctx: ExecutionContext) => Promise<Response>;
/**
 * @deprecated This has been renamed to createMcpHandler, and experimental_createMcpHandler will be removed in the next major version
 */
declare function experimental_createMcpHandler(server: McpServer | Server, options?: CreateMcpHandlerOptions): (request: Request, env: unknown, ctx: ExecutionContext) => Promise<Response>;
//#endregion
//#region src/mcp/auth-context.d.ts
interface McpAuthContext {
  props: Record<string, unknown>;
}
declare function getMcpAuthContext(): McpAuthContext | undefined;
//#endregion
//#region src/mcp/index.d.ts
declare abstract class McpAgent<Env = unknown, State = unknown, Props extends Record<string, unknown> = Record<string, unknown>> extends Agent<Env, State, Props> {
  private _transport?;
  props?: Props;
  abstract server: MaybePromise<McpServer | Server>;
  abstract init(): Promise<void>;
  setInitializeRequest(initializeRequest: JSONRPCMessage): Promise<void>;
  getInitializeRequest(): Promise<JSONRPCMessage | undefined>;
  /** Read the transport type for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getTransportType(): BaseTransportType;
  /** Read the sessionId for this agent.
   * This relies on the naming scheme being `sse:${sessionId}`
   * or `streamable-http:${sessionId}`.
   */
  getSessionId(): string;
  /** Get the unique WebSocket. SSE transport only. */
  private getWebSocket;
  /** Returns a new transport matching the type of the Agent. */
  private initTransport;
  /** Update and store the props */
  updateProps(props?: Props): Promise<void>;
  reinitializeServer(): Promise<void>;
  /** Sets up the MCP transport and server every time the Agent is started.*/
  onStart(props?: Props): Promise<void>;
  /** Validates new WebSocket connections. */
  onConnect(conn: Connection, {
    request: req
  }: ConnectionContext): Promise<void>;
  /** Handles MCP Messages for the legacy SSE transport. */
  onSSEMcpMessage(_sessionId: string, messageBody: unknown): Promise<Error | null>;
  /** Elicit user input with a message and schema */
  elicitInput(params: {
    message: string;
    requestedSchema: unknown;
  }): Promise<ElicitResult$1>;
  /** Wait for elicitation response through storage polling */
  private _waitForElicitationResponse;
  /** Handle elicitation responses */
  private _handleElicitationResponse;
  /** Return a handler for the given path for this MCP.
   * Defaults to Streamable HTTP transport.
   */
  static serve(path: string, {
    binding,
    corsOptions,
    transport,
    jurisdiction
  }?: ServeOptions): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  /**
   * Legacy api
   **/
  static mount(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
  static serveSSE(path: string, opts?: Omit<ServeOptions, "transport">): {
    fetch<Env>(this: void, request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;
  };
}
//#endregion
export { type CreateMcpHandlerOptions, type ElicitRequest, ElicitRequestSchema, type ElicitResult, type MCPClientOAuthCallbackConfig, type MCPClientOAuthResult, McpAgent, type McpAuthContext, type OAuthExecutionContext, SSEEdgeClientTransport, StreamableHTTPEdgeClientTransport, WorkerTransport, type WorkerTransportOptions, createMcpHandler, experimental_createMcpHandler, getMcpAuthContext };
//# sourceMappingURL=index.d.ts.map