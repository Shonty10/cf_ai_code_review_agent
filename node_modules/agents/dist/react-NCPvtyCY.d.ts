import { m as MCPServersState, t as Agent } from "./index-DFqsR7mb.js";
import { n as RPCMethod, t as Method } from "./serializable-CymX8ovI.js";
import { i as StreamOptions } from "./client-CbWe9FBd.js";
import { PartySocket } from "partysocket";
import { usePartySocket } from "partysocket/react";

//#region src/react.d.ts
type QueryObject = Record<string, string | null>;
/**
 * Options for the useAgent hook
 * @template State Type of the Agent's state
 */
type UseAgentOptions<State = unknown> = Omit<
  Parameters<typeof usePartySocket>[0],
  "party" | "room" | "query"
> & {
  /** Name of the agent to connect to */
  agent: string;
  /** Name of the specific Agent instance */
  name?: string;
  /** Query parameters - can be static object or async function */
  query?: QueryObject | (() => Promise<QueryObject>);
  /** Dependencies for async query caching */
  queryDeps?: unknown[];
  /** Cache TTL in milliseconds for auth tokens/time-sensitive data */
  cacheTtl?: number;
  /** Called when the Agent's state is updated */
  onStateUpdate?: (state: State, source: "server" | "client") => void;
  /** Called when MCP server state is updated */
  onMcpUpdate?: (mcpServers: MCPServersState) => void;
};
type AllOptional<T$1> = T$1 extends [infer A, ...infer R]
  ? undefined extends A
    ? AllOptional<R>
    : false
  : true;
type RPCMethods<T$1> = {
  [K in keyof T$1 as T$1[K] extends RPCMethod<T$1[K]> ? K : never]: RPCMethod<
    T$1[K]
  >;
};
type OptionalParametersMethod<T$1 extends RPCMethod> =
  AllOptional<Parameters<T$1>> extends true ? T$1 : never;
type AgentMethods<T$1> = Omit<RPCMethods<T$1>, keyof Agent<any, any>>;
type OptionalAgentMethods<T$1> = {
  [K in keyof AgentMethods<T$1> as AgentMethods<T$1>[K] extends OptionalParametersMethod<
    AgentMethods<T$1>[K]
  >
    ? K
    : never]: OptionalParametersMethod<AgentMethods<T$1>[K]>;
};
type RequiredAgentMethods<T$1> = Omit<
  AgentMethods<T$1>,
  keyof OptionalAgentMethods<T$1>
>;
type AgentPromiseReturnType<T$1, K$1 extends keyof AgentMethods<T$1>> =
  ReturnType<AgentMethods<T$1>[K$1]> extends Promise<any>
    ? ReturnType<AgentMethods<T$1>[K$1]>
    : Promise<ReturnType<AgentMethods<T$1>[K$1]>>;
type OptionalArgsAgentMethodCall<AgentT> = <
  K extends keyof OptionalAgentMethods<AgentT>
>(
  method: K,
  args?: Parameters<OptionalAgentMethods<AgentT>[K]>,
  streamOptions?: StreamOptions
) => AgentPromiseReturnType<AgentT, K>;
type RequiredArgsAgentMethodCall<AgentT> = <
  K extends keyof RequiredAgentMethods<AgentT>
>(
  method: K,
  args: Parameters<RequiredAgentMethods<AgentT>[K]>,
  streamOptions?: StreamOptions
) => AgentPromiseReturnType<AgentT, K>;
type AgentMethodCall<AgentT> = OptionalArgsAgentMethodCall<AgentT> &
  RequiredArgsAgentMethodCall<AgentT>;
type UntypedAgentMethodCall = <T = unknown>(
  method: string,
  args?: unknown[],
  streamOptions?: StreamOptions
) => Promise<T>;
type AgentStub<T$1> = {
  [K in keyof AgentMethods<T$1>]: (
    ...args: Parameters<AgentMethods<T$1>[K]>
  ) => AgentPromiseReturnType<AgentMethods<T$1>, K>;
};
type UntypedAgentStub = Record<string, Method>;
/**
 * React hook for connecting to an Agent
 */
declare function useAgent<State = unknown>(
  options: UseAgentOptions<State>
): PartySocket & {
  agent: string;
  name: string;
  setState: (state: State) => void;
  call: UntypedAgentMethodCall;
  stub: UntypedAgentStub;
};
declare function useAgent<
  AgentT extends {
    get state(): State;
  },
  State
>(
  options: UseAgentOptions<State>
): PartySocket & {
  agent: string;
  name: string;
  setState: (state: State) => void;
  call: AgentMethodCall<AgentT>;
  stub: AgentStub<AgentT>;
};
//#endregion
export { useAgent as n, UseAgentOptions as t };
//# sourceMappingURL=react-NCPvtyCY.d.ts.map
